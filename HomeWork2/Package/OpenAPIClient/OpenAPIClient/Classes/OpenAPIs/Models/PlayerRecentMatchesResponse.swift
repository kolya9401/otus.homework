//
// PlayerRecentMatchesResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** match */
public struct PlayerRecentMatchesResponse: Codable, JSONEncodable, Hashable {

    /** The ID number of the match assigned by Valve */
    public var matchId: Int?
    /** Which slot the player is in. 0-127 are Radiant, 128-255 are Dire */
    public var playerSlot: Int?
    /** Boolean indicating whether Radiant won the match */
    public var radiantWin: Bool?
    /** Duration of the game in seconds */
    public var duration: Int?
    /** Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json */
    public var gameMode: Int?
    /** Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json */
    public var lobbyType: Int?
    /** The ID value of the hero played */
    public var heroId: Int?
    /** The Unix timestamp at which the game started */
    public var startTime: Int?
    /** version */
    public var version: Int?
    /** Total kills the player had at the end of the match */
    public var kills: Int?
    /** Total deaths the player had at the end of the match */
    public var deaths: Int?
    /** Total assists the player had at the end of the match */
    public var assists: Int?
    /** Skill bracket assigned by Valve (Normal, High, Very High). If the skill is unknown, will return null. */
    public var skill: Int?
    /** Average rank of players with public match data */
    public var averageRank: Int?
    /** Experience Per Minute obtained by the player */
    public var xpPerMin: Int?
    /** Average gold per minute of the player */
    public var goldPerMin: Int?
    /** Total hero damage to enemy heroes */
    public var heroDamage: Int?
    /** Total healing of ally heroes */
    public var heroHealing: Int?
    /** Total last hits the player had at the end of the match */
    public var lastHits: Int?
    /** Integer corresponding to which lane the player laned in for the match */
    public var lane: Int?
    /** lane_role */
    public var laneRole: Int?
    /** Boolean describing whether or not the player roamed */
    public var isRoaming: Bool?
    /** cluster */
    public var cluster: Int?
    /** Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned */
    public var leaverStatus: Int?
    /** Size of the players party. If not in a party, will return 1. */
    public var partySize: Int?
    /** 1-indexed facet, see https://github.com/odota/dotaconstants/blob/master/build/hero_abilities.json */
    public var heroVariant: Int?

    public init(matchId: Int? = nil, playerSlot: Int? = nil, radiantWin: Bool? = nil, duration: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, heroId: Int? = nil, startTime: Int? = nil, version: Int? = nil, kills: Int? = nil, deaths: Int? = nil, assists: Int? = nil, skill: Int? = nil, averageRank: Int? = nil, xpPerMin: Int? = nil, goldPerMin: Int? = nil, heroDamage: Int? = nil, heroHealing: Int? = nil, lastHits: Int? = nil, lane: Int? = nil, laneRole: Int? = nil, isRoaming: Bool? = nil, cluster: Int? = nil, leaverStatus: Int? = nil, partySize: Int? = nil, heroVariant: Int? = nil) {
        self.matchId = matchId
        self.playerSlot = playerSlot
        self.radiantWin = radiantWin
        self.duration = duration
        self.gameMode = gameMode
        self.lobbyType = lobbyType
        self.heroId = heroId
        self.startTime = startTime
        self.version = version
        self.kills = kills
        self.deaths = deaths
        self.assists = assists
        self.skill = skill
        self.averageRank = averageRank
        self.xpPerMin = xpPerMin
        self.goldPerMin = goldPerMin
        self.heroDamage = heroDamage
        self.heroHealing = heroHealing
        self.lastHits = lastHits
        self.lane = lane
        self.laneRole = laneRole
        self.isRoaming = isRoaming
        self.cluster = cluster
        self.leaverStatus = leaverStatus
        self.partySize = partySize
        self.heroVariant = heroVariant
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case matchId = "match_id"
        case playerSlot = "player_slot"
        case radiantWin = "radiant_win"
        case duration
        case gameMode = "game_mode"
        case lobbyType = "lobby_type"
        case heroId = "hero_id"
        case startTime = "start_time"
        case version
        case kills
        case deaths
        case assists
        case skill
        case averageRank = "average_rank"
        case xpPerMin = "xp_per_min"
        case goldPerMin = "gold_per_min"
        case heroDamage = "hero_damage"
        case heroHealing = "hero_healing"
        case lastHits = "last_hits"
        case lane
        case laneRole = "lane_role"
        case isRoaming = "is_roaming"
        case cluster
        case leaverStatus = "leaver_status"
        case partySize = "party_size"
        case heroVariant = "hero_variant"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(matchId, forKey: .matchId)
        try container.encodeIfPresent(playerSlot, forKey: .playerSlot)
        try container.encodeIfPresent(radiantWin, forKey: .radiantWin)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encodeIfPresent(gameMode, forKey: .gameMode)
        try container.encodeIfPresent(lobbyType, forKey: .lobbyType)
        try container.encodeIfPresent(heroId, forKey: .heroId)
        try container.encodeIfPresent(startTime, forKey: .startTime)
        try container.encodeIfPresent(version, forKey: .version)
        try container.encodeIfPresent(kills, forKey: .kills)
        try container.encodeIfPresent(deaths, forKey: .deaths)
        try container.encodeIfPresent(assists, forKey: .assists)
        try container.encodeIfPresent(skill, forKey: .skill)
        try container.encodeIfPresent(averageRank, forKey: .averageRank)
        try container.encodeIfPresent(xpPerMin, forKey: .xpPerMin)
        try container.encodeIfPresent(goldPerMin, forKey: .goldPerMin)
        try container.encodeIfPresent(heroDamage, forKey: .heroDamage)
        try container.encodeIfPresent(heroHealing, forKey: .heroHealing)
        try container.encodeIfPresent(lastHits, forKey: .lastHits)
        try container.encodeIfPresent(lane, forKey: .lane)
        try container.encodeIfPresent(laneRole, forKey: .laneRole)
        try container.encodeIfPresent(isRoaming, forKey: .isRoaming)
        try container.encodeIfPresent(cluster, forKey: .cluster)
        try container.encodeIfPresent(leaverStatus, forKey: .leaverStatus)
        try container.encodeIfPresent(partySize, forKey: .partySize)
        try container.encodeIfPresent(heroVariant, forKey: .heroVariant)
    }
}

