//
// PlayersAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class PlayersAPI {

    /**
     GET /players/{account_id}
     
     - parameter accountId: (path) Steam32 account ID 
     - returns: PlayersResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountId(accountId: Int) async throws -> PlayersResponse {
        return try await getPlayersByAccountIdWithRequestBuilder(accountId: accountId).execute().body
    }

    /**
     GET /players/{account_id}
     - GET /players/{account_id}
     - Player data
     - parameter accountId: (path) Steam32 account ID 
     - returns: RequestBuilder<PlayersResponse> 
     */
    open class func getPlayersByAccountIdWithRequestBuilder(accountId: Int) -> RequestBuilder<PlayersResponse> {
        var localVariablePath = "/players/{account_id}"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PlayersResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/histograms
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter field: (path) Field to aggregate on 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: [AnyCodable]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdHistogramsByField(accountId: Int, field: String, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> [AnyCodable] {
        return try await getPlayersByAccountIdHistogramsByFieldWithRequestBuilder(accountId: accountId, field: field, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/histograms
     - GET /players/{account_id}/histograms/{field}
     - Distribution of matches in a single stat
     - parameter accountId: (path) Steam32 account ID 
     - parameter field: (path) Field to aggregate on 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<[AnyCodable]> 
     */
    open class func getPlayersByAccountIdHistogramsByFieldWithRequestBuilder(accountId: Int, field: String, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<[AnyCodable]> {
        var localVariablePath = "/players/{account_id}/histograms/{field}"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let fieldPreEscape = "\(APIHelper.mapValueToPathItem(field))"
        let fieldPostEscape = fieldPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{field}", with: fieldPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[AnyCodable]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/counts
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: PlayerCountsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectCounts(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> PlayerCountsResponse {
        return try await getPlayersByAccountIdSelectCountsWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/counts
     - GET /players/{account_id}/counts
     - Counts in categories
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<PlayerCountsResponse> 
     */
    open class func getPlayersByAccountIdSelectCountsWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<PlayerCountsResponse> {
        var localVariablePath = "/players/{account_id}/counts"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PlayerCountsResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/heroes
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: [PlayerHeroesResponse]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectHeroes(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> [PlayerHeroesResponse] {
        return try await getPlayersByAccountIdSelectHeroesWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/heroes
     - GET /players/{account_id}/heroes
     - Heroes played
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<[PlayerHeroesResponse]> 
     */
    open class func getPlayersByAccountIdSelectHeroesWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<[PlayerHeroesResponse]> {
        var localVariablePath = "/players/{account_id}/heroes"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[PlayerHeroesResponse]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/matches
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - parameter project: (query) Fields to project (array) (optional)
     - returns: [PlayerMatchesResponse]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectMatches(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil, project: String? = nil) async throws -> [PlayerMatchesResponse] {
        return try await getPlayersByAccountIdSelectMatchesWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort, project: project).execute().body
    }

    /**
     GET /players/{account_id}/matches
     - GET /players/{account_id}/matches
     - Matches played
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - parameter project: (query) Fields to project (array) (optional)
     - returns: RequestBuilder<[PlayerMatchesResponse]> 
     */
    open class func getPlayersByAccountIdSelectMatchesWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil, project: String? = nil) -> RequestBuilder<[PlayerMatchesResponse]> {
        var localVariablePath = "/players/{account_id}/matches"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "project": (wrappedValue: project?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[PlayerMatchesResponse]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/peers
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: [PlayerPeersResponse]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectPeers(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> [PlayerPeersResponse] {
        return try await getPlayersByAccountIdSelectPeersWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/peers
     - GET /players/{account_id}/peers
     - Players played with
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<[PlayerPeersResponse]> 
     */
    open class func getPlayersByAccountIdSelectPeersWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<[PlayerPeersResponse]> {
        var localVariablePath = "/players/{account_id}/peers"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[PlayerPeersResponse]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/pros
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: [PlayerProsResponse]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectPros(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> [PlayerProsResponse] {
        return try await getPlayersByAccountIdSelectProsWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/pros
     - GET /players/{account_id}/pros
     - Pro players played with
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<[PlayerProsResponse]> 
     */
    open class func getPlayersByAccountIdSelectProsWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<[PlayerProsResponse]> {
        var localVariablePath = "/players/{account_id}/pros"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[PlayerProsResponse]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/rankings
     
     - parameter accountId: (path) Steam32 account ID 
     - returns: [PlayerRankingsResponse]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectRankings(accountId: Int) async throws -> [PlayerRankingsResponse] {
        return try await getPlayersByAccountIdSelectRankingsWithRequestBuilder(accountId: accountId).execute().body
    }

    /**
     GET /players/{account_id}/rankings
     - GET /players/{account_id}/rankings
     - Player hero rankings
     - parameter accountId: (path) Steam32 account ID 
     - returns: RequestBuilder<[PlayerRankingsResponse]> 
     */
    open class func getPlayersByAccountIdSelectRankingsWithRequestBuilder(accountId: Int) -> RequestBuilder<[PlayerRankingsResponse]> {
        var localVariablePath = "/players/{account_id}/rankings"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[PlayerRankingsResponse]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/ratings
     
     - parameter accountId: (path) Steam32 account ID 
     - returns: [PlayerRatingsResponse]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectRatings(accountId: Int) async throws -> [PlayerRatingsResponse] {
        return try await getPlayersByAccountIdSelectRatingsWithRequestBuilder(accountId: accountId).execute().body
    }

    /**
     GET /players/{account_id}/ratings
     - GET /players/{account_id}/ratings
     - Player rating history
     - parameter accountId: (path) Steam32 account ID 
     - returns: RequestBuilder<[PlayerRatingsResponse]> 
     */
    open class func getPlayersByAccountIdSelectRatingsWithRequestBuilder(accountId: Int) -> RequestBuilder<[PlayerRatingsResponse]> {
        var localVariablePath = "/players/{account_id}/ratings"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[PlayerRatingsResponse]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/recentMatches
     
     - parameter accountId: (path) Steam32 account ID 
     - returns: [[PlayerRecentMatchesResponse]]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectRecentMatches(accountId: Int) async throws -> [[PlayerRecentMatchesResponse]] {
        return try await getPlayersByAccountIdSelectRecentMatchesWithRequestBuilder(accountId: accountId).execute().body
    }

    /**
     GET /players/{account_id}/recentMatches
     - GET /players/{account_id}/recentMatches
     - Recent matches played
     - parameter accountId: (path) Steam32 account ID 
     - returns: RequestBuilder<[[PlayerRecentMatchesResponse]]> 
     */
    open class func getPlayersByAccountIdSelectRecentMatchesWithRequestBuilder(accountId: Int) -> RequestBuilder<[[PlayerRecentMatchesResponse]]> {
        var localVariablePath = "/players/{account_id}/recentMatches"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[[PlayerRecentMatchesResponse]]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/totals
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: [PlayerTotalsResponse]
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectTotals(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> [PlayerTotalsResponse] {
        return try await getPlayersByAccountIdSelectTotalsWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/totals
     - GET /players/{account_id}/totals
     - Totals in stats
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<[PlayerTotalsResponse]> 
     */
    open class func getPlayersByAccountIdSelectTotalsWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<[PlayerTotalsResponse]> {
        var localVariablePath = "/players/{account_id}/totals"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[PlayerTotalsResponse]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/wardmap
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: PlayerWardMapResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectWardmap(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> PlayerWardMapResponse {
        return try await getPlayersByAccountIdSelectWardmapWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/wardmap
     - GET /players/{account_id}/wardmap
     - Wards placed in matches played
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<PlayerWardMapResponse> 
     */
    open class func getPlayersByAccountIdSelectWardmapWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<PlayerWardMapResponse> {
        var localVariablePath = "/players/{account_id}/wardmap"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PlayerWardMapResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/wl
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: PlayerWinLossResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectWl(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> PlayerWinLossResponse {
        return try await getPlayersByAccountIdSelectWlWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/wl
     - GET /players/{account_id}/wl
     - Win/Loss count
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<PlayerWinLossResponse> 
     */
    open class func getPlayersByAccountIdSelectWlWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<PlayerWinLossResponse> {
        var localVariablePath = "/players/{account_id}/wl"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PlayerWinLossResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     GET /players/{account_id}/wordcloud
     
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: PlayerWordCloudResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func getPlayersByAccountIdSelectWordcloud(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) async throws -> PlayerWordCloudResponse {
        return try await getPlayersByAccountIdSelectWordcloudWithRequestBuilder(accountId: accountId, limit: limit, offset: offset, win: win, patch: patch, gameMode: gameMode, lobbyType: lobbyType, region: region, date: date, laneRole: laneRole, heroId: heroId, isRadiant: isRadiant, includedAccountId: includedAccountId, excludedAccountId: excludedAccountId, withHeroId: withHeroId, againstHeroId: againstHeroId, significant: significant, having: having, sort: sort).execute().body
    }

    /**
     GET /players/{account_id}/wordcloud
     - GET /players/{account_id}/wordcloud
     - Words said/read in matches played
     - parameter accountId: (path) Steam32 account ID 
     - parameter limit: (query) Number of matches to limit to (optional)
     - parameter offset: (query) Number of matches to offset start by (optional)
     - parameter win: (query) Whether the player won (optional)
     - parameter patch: (query) Patch ID, from dotaconstants (optional)
     - parameter gameMode: (query) Game Mode ID (optional)
     - parameter lobbyType: (query) Lobby type ID (optional)
     - parameter region: (query) Region ID (optional)
     - parameter date: (query) Days previous (optional)
     - parameter laneRole: (query) Lane Role ID (optional)
     - parameter heroId: (query) Hero ID (optional)
     - parameter isRadiant: (query) Whether the player was radiant (optional)
     - parameter includedAccountId: (query) Account IDs in the match (array) (optional)
     - parameter excludedAccountId: (query) Account IDs not in the match (array) (optional)
     - parameter withHeroId: (query) Hero IDs on the player&#39;s team (array) (optional)
     - parameter againstHeroId: (query) Hero IDs against the player&#39;s team (array) (optional)
     - parameter significant: (query) Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches. (optional)
     - parameter having: (query) The minimum number of games played, for filtering hero stats (optional)
     - parameter sort: (query) The field to return matches sorted by in descending order (optional)
     - returns: RequestBuilder<PlayerWordCloudResponse> 
     */
    open class func getPlayersByAccountIdSelectWordcloudWithRequestBuilder(accountId: Int, limit: Int? = nil, offset: Int? = nil, win: Int? = nil, patch: Int? = nil, gameMode: Int? = nil, lobbyType: Int? = nil, region: Int? = nil, date: Int? = nil, laneRole: Int? = nil, heroId: Int? = nil, isRadiant: Int? = nil, includedAccountId: Int? = nil, excludedAccountId: Int? = nil, withHeroId: Int? = nil, againstHeroId: Int? = nil, significant: Int? = nil, having: Int? = nil, sort: String? = nil) -> RequestBuilder<PlayerWordCloudResponse> {
        var localVariablePath = "/players/{account_id}/wordcloud"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "limit": (wrappedValue: limit?.encodeToJSON(), isExplode: true),
            "offset": (wrappedValue: offset?.encodeToJSON(), isExplode: true),
            "win": (wrappedValue: win?.encodeToJSON(), isExplode: true),
            "patch": (wrappedValue: patch?.encodeToJSON(), isExplode: true),
            "game_mode": (wrappedValue: gameMode?.encodeToJSON(), isExplode: true),
            "lobby_type": (wrappedValue: lobbyType?.encodeToJSON(), isExplode: true),
            "region": (wrappedValue: region?.encodeToJSON(), isExplode: true),
            "date": (wrappedValue: date?.encodeToJSON(), isExplode: true),
            "lane_role": (wrappedValue: laneRole?.encodeToJSON(), isExplode: true),
            "hero_id": (wrappedValue: heroId?.encodeToJSON(), isExplode: true),
            "is_radiant": (wrappedValue: isRadiant?.encodeToJSON(), isExplode: true),
            "included_account_id": (wrappedValue: includedAccountId?.encodeToJSON(), isExplode: true),
            "excluded_account_id": (wrappedValue: excludedAccountId?.encodeToJSON(), isExplode: true),
            "with_hero_id": (wrappedValue: withHeroId?.encodeToJSON(), isExplode: true),
            "against_hero_id": (wrappedValue: againstHeroId?.encodeToJSON(), isExplode: true),
            "significant": (wrappedValue: significant?.encodeToJSON(), isExplode: true),
            "having": (wrappedValue: having?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PlayerWordCloudResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     POST /players/{account_id}/refresh
     
     - parameter accountId: (path) Steam32 account ID 
     - returns: AnyCodable
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func postRefresh(accountId: Int) async throws -> AnyCodable {
        return try await postRefreshWithRequestBuilder(accountId: accountId).execute().body
    }

    /**
     POST /players/{account_id}/refresh
     - POST /players/{account_id}/refresh
     - Refresh player match history
     - parameter accountId: (path) Steam32 account ID 
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func postRefreshWithRequestBuilder(accountId: Int) -> RequestBuilder<AnyCodable> {
        var localVariablePath = "/players/{account_id}/refresh"
        let accountIdPreEscape = "\(APIHelper.mapValueToPathItem(accountId))"
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{account_id}", with: accountIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }
}
