//
// TeamMatchObjectResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct TeamMatchObjectResponse: Codable, JSONEncodable, Hashable {

    /** The ID number of the match assigned by Valve */
    public var matchId: Int?
    /** Whether the team/player/hero was on Radiant */
    public var radiant: Bool?
    /** Boolean indicating whether Radiant won the match */
    public var radiantWin: Bool?
    /** Number of kills the Radiant team had when the match ended */
    public var radiantScore: Int?
    /** Number of kills the Dire team had when the match ended */
    public var direScore: Int?
    /** Duration of the game in seconds */
    public var duration: Int?
    /** The Unix timestamp at which the game started */
    public var startTime: Int?
    /** Identifier for the league the match took place in */
    public var leagueid: Int?
    /** Name of league the match took place in */
    public var leagueName: String?
    /** cluster */
    public var cluster: Int?
    /** Opposing team identifier */
    public var opposingTeamId: Int?
    /** Opposing team name, e.g. 'Evil Geniuses' */
    public var opposingTeamName: String?
    /** Opposing team logo url */
    public var opposingTeamLogo: String?

    public init(matchId: Int? = nil, radiant: Bool? = nil, radiantWin: Bool? = nil, radiantScore: Int? = nil, direScore: Int? = nil, duration: Int? = nil, startTime: Int? = nil, leagueid: Int? = nil, leagueName: String? = nil, cluster: Int? = nil, opposingTeamId: Int? = nil, opposingTeamName: String? = nil, opposingTeamLogo: String? = nil) {
        self.matchId = matchId
        self.radiant = radiant
        self.radiantWin = radiantWin
        self.radiantScore = radiantScore
        self.direScore = direScore
        self.duration = duration
        self.startTime = startTime
        self.leagueid = leagueid
        self.leagueName = leagueName
        self.cluster = cluster
        self.opposingTeamId = opposingTeamId
        self.opposingTeamName = opposingTeamName
        self.opposingTeamLogo = opposingTeamLogo
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case matchId = "match_id"
        case radiant
        case radiantWin = "radiant_win"
        case radiantScore = "radiant_score"
        case direScore = "dire_score"
        case duration
        case startTime = "start_time"
        case leagueid
        case leagueName = "league_name"
        case cluster
        case opposingTeamId = "opposing_team_id"
        case opposingTeamName = "opposing_team_name"
        case opposingTeamLogo = "opposing_team_logo"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(matchId, forKey: .matchId)
        try container.encodeIfPresent(radiant, forKey: .radiant)
        try container.encodeIfPresent(radiantWin, forKey: .radiantWin)
        try container.encodeIfPresent(radiantScore, forKey: .radiantScore)
        try container.encodeIfPresent(direScore, forKey: .direScore)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encodeIfPresent(startTime, forKey: .startTime)
        try container.encodeIfPresent(leagueid, forKey: .leagueid)
        try container.encodeIfPresent(leagueName, forKey: .leagueName)
        try container.encodeIfPresent(cluster, forKey: .cluster)
        try container.encodeIfPresent(opposingTeamId, forKey: .opposingTeamId)
        try container.encodeIfPresent(opposingTeamName, forKey: .opposingTeamName)
        try container.encodeIfPresent(opposingTeamLogo, forKey: .opposingTeamLogo)
    }
}

