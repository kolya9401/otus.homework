//
// MatchResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct MatchResponse: Codable, JSONEncodable, Hashable {

    /** The ID number of the match assigned by Valve */
    public var matchId: Int?
    /** Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game. */
    public var barracksStatusDire: Int?
    /** Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game. */
    public var barracksStatusRadiant: Int?
    /** Array containing information on the chat of the game */
    public var chat: [MatchResponseChatInner]?
    /** cluster */
    public var cluster: Int?
    /** cosmetics */
    public var cosmetics: [String: Int]?
    /** Number of kills the Dire team had when the match ended */
    public var direScore: Int?
    /** draft_timings */
    public var draftTimings: [MatchResponseDraftTimingsInner]?
    /** Duration of the game in seconds */
    public var duration: Int?
    /** engine */
    public var engine: Int?
    /** Time in seconds at which first blood occurred */
    public var firstBloodTime: Int?
    /** Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json */
    public var gameMode: Int?
    /** Number of human players in the game */
    public var humanPlayers: Int?
    /** leagueid */
    public var leagueid: Int?
    /** Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json */
    public var lobbyType: Int?
    /** match_seq_num */
    public var matchSeqNum: Int?
    /** Number of negative votes the replay received in the in-game client */
    public var negativeVotes: Int?
    /** objectives */
    public var objectives: [AnyCodable]?
    /** Array containing information on the draft. Each item contains a boolean relating to whether the choice is a pick or a ban, the hero ID, the team the picked or banned it, and the order. */
    public var picksBans: [MatchResponsePicksBansInner]?
    /** Number of positive votes the replay received in the in-game client */
    public var positiveVotes: Int?
    /** Array of the Radiant gold advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their gold disadvantage.  */
    public var radiantGoldAdv: [Double]?
    /** Number of kills the Radiant team had when the match ended */
    public var radiantScore: Int?
    /** Boolean indicating whether Radiant won the match */
    public var radiantWin: Bool?
    /** Array of the Radiant experience advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their experience disadvantage.  */
    public var radiantXpAdv: [Double]?
    /** The Unix timestamp at which the game started */
    public var startTime: Int?
    /** teamfights */
    public var teamfights: [AnyCodable]?
    /** Bitmask. An integer that represents a binary of which Dire towers are still standing. */
    public var towerStatusDire: Int?
    /** Bitmask. An integer that represents a binary of which Radiant towers are still standing. */
    public var towerStatusRadiant: Int?
    /** Parse version, used internally by OpenDota */
    public var version: Int?
    /** replay_salt */
    public var replaySalt: Int?
    /** series_id */
    public var seriesId: Int?
    /** series_type */
    public var seriesType: Int?
    /** radiant_team */
    public var radiantTeam: AnyCodable?
    /** dire_team */
    public var direTeam: AnyCodable?
    /** league */
    public var league: AnyCodable?
    /** Skill bracket assigned by Valve (Normal, High, Very High) */
    public var skill: Int?
    /** Array of information on individual players */
    public var players: [MatchResponsePlayersInner]?
    /** Patch ID, from dotaconstants */
    public var patch: Int?
    /** Integer corresponding to the region the game was played on */
    public var region: Int?
    /** Word counts of the all chat messages in the player's games */
    public var allWordCounts: AnyCodable?
    /** Word counts of the player's all chat messages */
    public var myWordCounts: AnyCodable?
    /** Maximum gold advantage of the player's team if they lost the match */
    public var _throw: Int?
    /** Maximum gold disadvantage of the player's team if they won the match */
    public var comeback: Int?
    /** Maximum gold disadvantage of the player's team if they lost the match */
    public var loss: Int?
    /** Maximum gold advantage of the player's team if they won the match */
    public var win: Int?
    /** replay_url */
    public var replayUrl: String?

    public init(matchId: Int? = nil, barracksStatusDire: Int? = nil, barracksStatusRadiant: Int? = nil, chat: [MatchResponseChatInner]? = nil, cluster: Int? = nil, cosmetics: [String: Int]? = nil, direScore: Int? = nil, draftTimings: [MatchResponseDraftTimingsInner]? = nil, duration: Int? = nil, engine: Int? = nil, firstBloodTime: Int? = nil, gameMode: Int? = nil, humanPlayers: Int? = nil, leagueid: Int? = nil, lobbyType: Int? = nil, matchSeqNum: Int? = nil, negativeVotes: Int? = nil, objectives: [AnyCodable]? = nil, picksBans: [MatchResponsePicksBansInner]? = nil, positiveVotes: Int? = nil, radiantGoldAdv: [Double]? = nil, radiantScore: Int? = nil, radiantWin: Bool? = nil, radiantXpAdv: [Double]? = nil, startTime: Int? = nil, teamfights: [AnyCodable]? = nil, towerStatusDire: Int? = nil, towerStatusRadiant: Int? = nil, version: Int? = nil, replaySalt: Int? = nil, seriesId: Int? = nil, seriesType: Int? = nil, radiantTeam: AnyCodable? = nil, direTeam: AnyCodable? = nil, league: AnyCodable? = nil, skill: Int? = nil, players: [MatchResponsePlayersInner]? = nil, patch: Int? = nil, region: Int? = nil, allWordCounts: AnyCodable? = nil, myWordCounts: AnyCodable? = nil, _throw: Int? = nil, comeback: Int? = nil, loss: Int? = nil, win: Int? = nil, replayUrl: String? = nil) {
        self.matchId = matchId
        self.barracksStatusDire = barracksStatusDire
        self.barracksStatusRadiant = barracksStatusRadiant
        self.chat = chat
        self.cluster = cluster
        self.cosmetics = cosmetics
        self.direScore = direScore
        self.draftTimings = draftTimings
        self.duration = duration
        self.engine = engine
        self.firstBloodTime = firstBloodTime
        self.gameMode = gameMode
        self.humanPlayers = humanPlayers
        self.leagueid = leagueid
        self.lobbyType = lobbyType
        self.matchSeqNum = matchSeqNum
        self.negativeVotes = negativeVotes
        self.objectives = objectives
        self.picksBans = picksBans
        self.positiveVotes = positiveVotes
        self.radiantGoldAdv = radiantGoldAdv
        self.radiantScore = radiantScore
        self.radiantWin = radiantWin
        self.radiantXpAdv = radiantXpAdv
        self.startTime = startTime
        self.teamfights = teamfights
        self.towerStatusDire = towerStatusDire
        self.towerStatusRadiant = towerStatusRadiant
        self.version = version
        self.replaySalt = replaySalt
        self.seriesId = seriesId
        self.seriesType = seriesType
        self.radiantTeam = radiantTeam
        self.direTeam = direTeam
        self.league = league
        self.skill = skill
        self.players = players
        self.patch = patch
        self.region = region
        self.allWordCounts = allWordCounts
        self.myWordCounts = myWordCounts
        self._throw = _throw
        self.comeback = comeback
        self.loss = loss
        self.win = win
        self.replayUrl = replayUrl
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case matchId = "match_id"
        case barracksStatusDire = "barracks_status_dire"
        case barracksStatusRadiant = "barracks_status_radiant"
        case chat
        case cluster
        case cosmetics
        case direScore = "dire_score"
        case draftTimings = "draft_timings"
        case duration
        case engine
        case firstBloodTime = "first_blood_time"
        case gameMode = "game_mode"
        case humanPlayers = "human_players"
        case leagueid
        case lobbyType = "lobby_type"
        case matchSeqNum = "match_seq_num"
        case negativeVotes = "negative_votes"
        case objectives
        case picksBans = "picks_bans"
        case positiveVotes = "positive_votes"
        case radiantGoldAdv = "radiant_gold_adv"
        case radiantScore = "radiant_score"
        case radiantWin = "radiant_win"
        case radiantXpAdv = "radiant_xp_adv"
        case startTime = "start_time"
        case teamfights
        case towerStatusDire = "tower_status_dire"
        case towerStatusRadiant = "tower_status_radiant"
        case version
        case replaySalt = "replay_salt"
        case seriesId = "series_id"
        case seriesType = "series_type"
        case radiantTeam = "radiant_team"
        case direTeam = "dire_team"
        case league
        case skill
        case players
        case patch
        case region
        case allWordCounts = "all_word_counts"
        case myWordCounts = "my_word_counts"
        case _throw = "throw"
        case comeback
        case loss
        case win
        case replayUrl = "replay_url"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(matchId, forKey: .matchId)
        try container.encodeIfPresent(barracksStatusDire, forKey: .barracksStatusDire)
        try container.encodeIfPresent(barracksStatusRadiant, forKey: .barracksStatusRadiant)
        try container.encodeIfPresent(chat, forKey: .chat)
        try container.encodeIfPresent(cluster, forKey: .cluster)
        try container.encodeIfPresent(cosmetics, forKey: .cosmetics)
        try container.encodeIfPresent(direScore, forKey: .direScore)
        try container.encodeIfPresent(draftTimings, forKey: .draftTimings)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encodeIfPresent(engine, forKey: .engine)
        try container.encodeIfPresent(firstBloodTime, forKey: .firstBloodTime)
        try container.encodeIfPresent(gameMode, forKey: .gameMode)
        try container.encodeIfPresent(humanPlayers, forKey: .humanPlayers)
        try container.encodeIfPresent(leagueid, forKey: .leagueid)
        try container.encodeIfPresent(lobbyType, forKey: .lobbyType)
        try container.encodeIfPresent(matchSeqNum, forKey: .matchSeqNum)
        try container.encodeIfPresent(negativeVotes, forKey: .negativeVotes)
        try container.encodeIfPresent(objectives, forKey: .objectives)
        try container.encodeIfPresent(picksBans, forKey: .picksBans)
        try container.encodeIfPresent(positiveVotes, forKey: .positiveVotes)
        try container.encodeIfPresent(radiantGoldAdv, forKey: .radiantGoldAdv)
        try container.encodeIfPresent(radiantScore, forKey: .radiantScore)
        try container.encodeIfPresent(radiantWin, forKey: .radiantWin)
        try container.encodeIfPresent(radiantXpAdv, forKey: .radiantXpAdv)
        try container.encodeIfPresent(startTime, forKey: .startTime)
        try container.encodeIfPresent(teamfights, forKey: .teamfights)
        try container.encodeIfPresent(towerStatusDire, forKey: .towerStatusDire)
        try container.encodeIfPresent(towerStatusRadiant, forKey: .towerStatusRadiant)
        try container.encodeIfPresent(version, forKey: .version)
        try container.encodeIfPresent(replaySalt, forKey: .replaySalt)
        try container.encodeIfPresent(seriesId, forKey: .seriesId)
        try container.encodeIfPresent(seriesType, forKey: .seriesType)
        try container.encodeIfPresent(radiantTeam, forKey: .radiantTeam)
        try container.encodeIfPresent(direTeam, forKey: .direTeam)
        try container.encodeIfPresent(league, forKey: .league)
        try container.encodeIfPresent(skill, forKey: .skill)
        try container.encodeIfPresent(players, forKey: .players)
        try container.encodeIfPresent(patch, forKey: .patch)
        try container.encodeIfPresent(region, forKey: .region)
        try container.encodeIfPresent(allWordCounts, forKey: .allWordCounts)
        try container.encodeIfPresent(myWordCounts, forKey: .myWordCounts)
        try container.encodeIfPresent(_throw, forKey: ._throw)
        try container.encodeIfPresent(comeback, forKey: .comeback)
        try container.encodeIfPresent(loss, forKey: .loss)
        try container.encodeIfPresent(win, forKey: .win)
        try container.encodeIfPresent(replayUrl, forKey: .replayUrl)
    }
}

